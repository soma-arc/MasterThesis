%#BIBTEX biber --bblencoding=utf8 -u -U --output_safechars main
%#!uplatex main.tex

\section{Preparation}

In this section, we introduce prerequisites to understand
Iterated Inversion System (IIS) and basic usage of IIS.

\subsection{Kleinian Groups}

Kleinian groups is discrete sub-group of the M\"obius transformation
groups. Briefly, group of the transformations which meet some conditions.

The word \textit{group} or \textit{transformation group} means a set of
transformations. 
We call initial elements of the group \textit{generators}.
For example, we assume there are two transformations $f(z)$ and $g(z)$.
We write transformations lower case, for example we write $a$ as $f(z)$
and $b$ as $g(z)$. Also, we use capitalized letters for inverse
transformations. 
We write compositions of transformations as line up letters.
For instance, $f(z) \circ g(z) \circ f(z)^{-1}$ is $abA$.
We call the letters \textit{word}.

In this paper, we follow the notations of Indra's Pearls
\cite{MumfordSeriesWright200204}, for more details, read the book.

\subsection{M\"obius Transformations and Inversions}

M\"obius transformations are defined in the extended complex plane,
$\hat{\mathbb{C}} = \mathbb{C} \cup \{\infty\}$ and expressed as linear
fractional transformation
$f(z)=\frac{az + b}{cz + d}$, where $a,~b,~c,~d,~z \in \hat{\mathbb{C}}$.
However, it is also known that we can construct them out of a finite
composition of inversions. For more details, see the chapter 1 of \cite{marden_2016}.

M\"obius transformations are classified into three types as \textit{loxodromic},
\textit{parabolic}, or \textit{elliptic}.
Loxodromic transformations have two fixed points and are conjugate to
scaling by complex numbers except for scaling by unit complex numbers.
Those whose multiplier is a positive real number
are also called hyperbolic transformations.Parabolic transformations
have one fixed point and are conjugate to parallel translations.
Elliptic transformations have two fixed points and are conjugate to rotations.

An inversion in a circle
is defined as $f(z) = \frac{r^2}{~\overline{z - c}~} + c$, where $c$ and
$r$ are center and radius of the circle.
Note that an inversion in a circle with infinite radius is the same as
a reflection over a line.
Also, sphere inversion can be derived from a similar equation, and an inversion
in a sphere with infinite radius is the same as
a reflection through a plane.

\subsection{Basic Methods for Visualization}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.333\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/cayleyGraph.png}
  \caption{\textit{Cayley Graph}}
  \label{fig:cayleyGraph}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.333\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/basic/catOrbit.png}
  \caption{\textit{Orbit of the image}}
  \label{fig:orbitCat}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.333\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/limitSet/limit.png}
  \caption{\textit{Limit set of the Kleinian group}}
  \label{fig:limit}
  \hspace*{\fill}
 \end{minipage}
\end{figure}

\noindent In this section, we introduce basic methods for visualizing Kleinian groups.
We consider \textit{cayley graph} of the Kleinian groups to enumerate elements
of the groups.
Figure \ref{fig:cayleyGraph} shows Cayley graph of the group generated
by two transformations.
The nodes of the graph represent compositions of elements of the group.
According to the way of traversing, 
there are two types of visualization of transformation groups.

Firstly, we can draw orbit of the group by traversing the cayley graph with
breadth first search.
See Figure \ref{fig:orbitCat}.
The cat in the center transformed by found words.
Moreover, we can consider tiling of the first tile.
If the group meet some conditions, we can tile them without gaps and
self intersections.
The circles and cats converges, and
we call the limit part the \textit{limit set} of the group.

Secondly, we can only draw the limit set of the group by traversing the
cayley graph with depth first search.
The limit set located at the end of Cayley graph. Thus, we use fixed
point of the transformation.
we apply obtained word to the fixed points.
For more details, read Indra's Pearls.
Figure \ref{fig:limit} shows one of the limit set of the Kleinian group.

However, there are some faults in these methods.
For example, if we increase the number of generators,
It takes too much time to traverse the graph because of
combinatorial explosion.
Also, We have to traverse all of the graph
even though we don't need images outside of the screen.
This is the reason why we need other methods to visualize Kleinian
groups.

\subsection{Iterated Inversion System (IIS)}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level0c.pdf}
  \subcaption{}
  \label{fig:level0}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level0invc.pdf}
  \subcaption{}
   \label{fig:level0inv}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level1c.pdf}
  \subcaption{}
   \label{fig:level1}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in,
  keepaspectratio]{./img/preparation/orbit/level1invc.pdf}
  \subcaption{}
  \label{fig:level1inv}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level2c.pdf}
  \subcaption{}
  \label{fig:level2}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{img/preparation/orbit/levelMaxc.pdf}
  \subcaption{}
  \label{fig:levelMax}
 \end{minipage}
 \caption{\textit{The process of rendering the orbit of Schottky disks}}
 \label{fig:schottkyProcess}
\end{figure}

\noindent To solve the problems we discussed in previous section,
we focus circle inversions and invent an efficient algorithm to
visualize \textit{circle inversion fractals} shown in Figure \ref{fig:schottkyProcess}\subref{fig:levelMax}.

The algorithm is called \textit{Iterated Inversion System (IIS.)}
It can visualize not only two dimensional circle inversion fractals but
also three dimensional sphere inversion fractals.

The fractal in Figure \ref{fig:schottkyProcess}\subref{fig:levelMax} shows the orbit of the first
four circles.
It is also Kleinian group composed of four circle inversions.
The process of generation of circle inversion fractals is
as follows.

\begin{enumerate}
 \item We need some disjoint disks to obtain circle inversion fractals.
       For example, we assume there are four orange disks as shown in
       Figure \ref{fig:schottkyProcess}\subref{fig:level0}. We call orange disks \textit{initial
       disks} and their boundary \textit{initial circles}.
 \item First of all, we focus on the white circle in Figure
       \ref{fig:schottkyProcess}\subref{fig:level0inv}. The inversion in the white circle moves the
       other three disks into the interior of the white circle.
 \item After we apply each inversion in the initial circle to the outer disks,
       we obtain twelve small disks. They are shown in Figure \ref{fig:schottkyProcess}\subref{fig:level1}.
 \item Next, we invert the twelve small disks in the initial circles.
       The inversion in the white circle moves the outer nine small disks
       into the interior of the white circle as shown in Figure \ref{fig:schottkyProcess}\subref{fig:level1inv}.
       Each inversion in the Schottky circle generates smaller disks, and we
       obtain Figure \ref{fig:schottkyProcess}\subref{fig:level2}.
 \item We continue iterating these process, that is, we continue
       applying each inversion in the initial circle to resulting
       smaller disks.
       Finally, we get Figure \ref{fig:schottkyProcess}\subref{fig:levelMax}.
\end{enumerate}

\subsubsection{Two Dimensional IIS}

\begin{figure}[htbp]
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/orbIIS.png}
  \caption{\textit{Orbit of blue point by IIS}}
  \label{fig:iisOrbit}
 \hspace*{\fill}
\end{figure}

IIS computes the depth of the circles point by point.
Thus, we can use parallel processing.
The images in this paper are rendered using \textit{OpenGL Shading
Language (GLSL)}.
For two dimensional fractals, the algorithm of IIS is as follows.

\noindent IIS is applied to each point on the plane and computes nesting depth of
the disk which contains the point.
The process of the algorithm is as follows.
First of all, if the point is contained in initial disks, we invert the
point in the boundary circle of the disk.
We continue applying inversions until the transformed point is in the
out side of the initial circles.
Figure \ref{fig:iisOrbit} shows orbit of the blue point transformed by
iterations of inversions.

Furthermore, a point actually at the limit set never reaches the
outside. So, we have to determine the maximum number of iterations in
advance to prevent the algorithm from running indeÔ¨Ånitely.
However, the points except for the limit set are guaranteed that they
are transformed to outside because inversions are involution.

 \begin{algorithm}
  \caption{Iterated Inversion System (IIS)}
  \label{arg:iis2d}
  \begin{algorithmic}
   \REQUIRE count $= 0$ and coordinates $=$ position determined by
   pixel
   \FOR{$i=0$ to MAX\_INVERSION}
   \STATE inOutside $\leftarrow$ \TRUE
   \FOR{ each inversion $I$ in circles }
   \IF{The circle $I$ contains coordinates}
   \STATE coordinates $\leftarrow$ $I(\text{coordinates})$
   \STATE INCREMENT count
   \STATE inOutside $\leftarrow$ \FALSE
   \ENDIF
   \ENDFOR
   \IF {inOutside}
   \STATE BREAK for
   \ENDIF
   \ENDFOR
   \STATE RETURN count
  \end{algorithmic}
 \end{algorithm}

\noindent Pseudo-code is in Algorithm \ref{arg:iis2d}.

\subsubsection{Three Dimensional Extension}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/3dExtension/3dKissingGenerator.png}
  \subcaption{\textit{Generator}}
  \label{fig:simpleGen}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/3dExtension/3dOrbit.png}
  \subcaption{\textit{The orbit of spheres}}
  \label{fig:simpleOrb}
  \hspace*{\fill}
 \end{minipage}
 \caption{\textit{The orbit of the sphere inversion fractal}}
 \label{fig:simpleGenOrb}
\end{figure}

In the similar manner to two dimensional algorithm,
we extend the IIS to visualize three-dimensional kleinian groups.
We extend circle inversion to sphere inversion easily, and we
compute the nesting depth of the sphere voxel by voxel.

We use \textit{ray tracing} to visualize three dimensional objects.
Ray tracing computes intersection between ray and objects algebraically.
There are two ways to render nesting spheres. First one is drawing
transparent spheres. Second one is \textit{volume rendering}.
However, it is difficult to render them efficiently, and
visualized images are not interesting.

Therefore we render the orbit of sphere in a similar way to the two
dimensional circle inversion fractals.
See Figure \ref{fig:simpleGenOrb}\subref{fig:simpleGen}. It shows
white six inversion spheres and green seed sphere.
Figure \ref{fig:simpleGenOrb}\subref{fig:simpleOrb} shows the orbit of
green sphere transformed by inversions in white spheres.

We use \textit{Sphere Tracing} \cite{hart1996sphere} to render three dimensional
fractals and orbit of the seed sphere.
Sphere Tracing is one of the algorithm to render implicit surfaces using
ray tracing.
In the following paragraphs, we introduce ray tracing and sphere tracing.

In the first place, we work a ray as something like a vector.
We set the origin of the ray to the position of the camera
and direction of the ray to the direction to each pixel on the screen
from the camera. Each pixel is colored according to the
first object the ray hits. 

In regular ray tracing, we calculate the intersection algebraically. 
On the other hand, in sphere tracing, we march the ‚Äútip‚Äù of the ray
along the direction of the ray step by step. 
To check how far the tip of the ray is from the objects, we need a
\textit{distance function}.
Distance function is a function which returns minimum distance between
given point and a target object. 
For example, let $P$ be a tip of a ray. A distance function of a sphere
whose center is $C$ and radius is $R$ is $f(x) = distance(P, C) - R$.

However, in regard to fractal rendering, it is difficult to
get an actual distance to its shape. So, we use lower estimated distance
as a return value of the distance function. The technique to approximate
distance is called \textit{distance estimation}.
For more details about fractal rendering, see also the blog
post\footnote{Mikael H Christensen, Distance Estimated 3D Fractals (Part I):\\ \quad\quad
\url{http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/}}
by Christensen. 

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/iis3d/modulo1.png}
  \caption{\textit{modulo1}}
  \label{fig:modulo1}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/iis3d/modulo2.png}
  \caption{\textit{modulo2}}
  \label{fig:modulo2}
  \hspace*{\fill}
 \end{minipage}
\end{figure}

%% „Åì„Åì„Åß„ÅØ‰∫åÊ¨°ÂÖÉ„ÅÆÂõ≥„ÅßËÄÉ„Åà„Çã
Before we introduce distance estimation, we introduce
well known technique to copy many objects in sphere tracing.
Instead of preparing many objects, we can use modulo operator
to get distance function to line the objects up.
See Figure \ref{fig:modulo1}. We assume there are blue disk, yellow ray and dotted
circle and lines.
Now, we want to distance function for circles.
We assume the nearest circle to the ray is in same dotted region.
We apply modulo operator to the ray and we can measure distance to blue
disk as in Figure \ref{fig:modulo2}.

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/iis3d/scaleIIS.png}
  \caption{\textit{scaling1}}
  \label{fig:iisScale1}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/iis3d/scaleIIS2.png}
  \caption{\textit{scaling2}}
  \label{fig:iisScale2}
  \hspace*{\fill}
 \end{minipage}
\end{figure}

Next, we consider scaling example. See Figure \ref{fig:iisScale1}.
There is a yellow ray and a blue disk, and orbit of scaling as
dotted blue circles.
The green dotted lines show scaling regions.
We assume that the nearest sphere to the tip of the ray is at
same regions. 
However, we only know the coordinates of the original blue
disk and tip of the ray.
Thus, we scale the tip of the ray to the same region to the blue disk
but, the distance between scaled ray and disk is also scaled.
So, we correct the scale dividing computed distance by Jacobian of
scaling.
If the scaling of the circle is $f(x) = 2x$, we divide the scale by
six.

%% Á∞°Âçò„Å™‰æã„Åã„ÇâÂßã„ÇÅ„ÇãÔºéÁêÉ„Ååy = ax„Å´„Çà„Å£„Å¶Âãï„ÅèËªåÈÅì„ÇíÊèèÁîª„Åô„Çã„Åì„Å®„ÇíËÄÉ„Åà„ÇãÔºé
%% Sphere tracing„Å´„ÅØÔºå„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíË§áË£Ω„Åô„Çã„Çà„ÅèÁü•„Çâ„Çå„Åü„ÅÑ„Åè„Å§„Åã„ÅÆ„ÉÜ„ÇØ
%% „Éã„ÉÉ„ÇØ„ÅåÂ≠òÂú®„Åó„Å¶„ÅÑ„ÇãÔºémod„Å´„Çà„ÇãrepetitionÔºé
%% ‰∏ÄÊ≠©„Åô„Åô„ÇÅ„Å¶ÔºåÂÆöÊï∞ÂÄç„Å´„Çà„ÇãËªåÈÅì„ÇíÊèèÁîª„Åô„Çã„Åì„Å®„ÇíËÄÉ„Åà„ÇãÔºéÂÜÜÁä∂„ÅÆÈ†òÂüü„ÇíËÄÉ
%% „Åà„Çã„Åì„Å®„Åå„Åß„Åç„ÇãÔºé„É¨„Ç§„ÅØÂêå„ÅòÈ†òÂüü„Å´„ÅÇ„ÇãÁêÉ„Å´ÊúÄ„ÇÇËøë„ÅÑ„Å®ËÄÉ„Åà„Çã„Å®Ôºå
%% „Åì„ÅÆ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅØË∑ùÈõ¢Èñ¢Êï∞„ÇíÁî®„ÅÑ„Å¶Áâ©‰Ωì„ÇíÊèèÁîª„Åô„ÇãÔºéÁâ©‰Ωì„ÅÆËªåÈÅì„ÇíSphere
%% Tracing„ÅßÊèèÁîª„Åô„ÇãÈöõ„Å´„ÅØÔºåÁâ©‰Ωì„ÅÆ„É§„Ç≥„Éì„Ç¢„É≥„Å´Ê≥®ÁõÆ„Åô„ÇãÔºé
%% ‰æã„Åà„Å∞ÔºåÁâ©‰Ωì„ÅÆÊã°Á∏Æ„ÅÆËªåÈÅì„ÇíSphereTracing„ÅßÊèè„Åè„Åü„ÇÅ„Å´„ÅØ
%% Êã°Á∏Æ„ÅÆ„É§„Ç≥„Éì„Ç¢„É≥„ÅØÔºåy = ax„ÅÆ„Å®„Åça„Åß„ÅÇ„ÇãÔºéÊúÄÁµÇÁöÑ„Å´„É§„Ç≥„Éì„Ç¢„É≥a„ÅßË∑ùÈõ¢„Çí
%% Ââ≤„Çã„Åì„Å®„ÅßÂÆüÈöõ„ÅÆË∑ùÈõ¢„ÇíÂæó„ÇãÔºé

In the similar manner to scaling, we can render sphere inversion
fractals.

\begin{algorithm}
 \caption{Distance Function}
 \label{iis3d}
 \begin{algorithmic}
  \REQUIRE count $= 0$, $d$ = MAX\_DISTANCE, $dr = 1.0$, and coordinates
  $=$ tip of the ray
  \FOR{$i=0$ to MAX\_INVERSION}
  \STATE inFundamentalDomain $\leftarrow$ \TRUE
  \FOR{ each Map $G$ in Maps}
  \IF{$G$ is available to coordinates}
  \STATE $dr \leftarrow dr * $ (Jacobian of $G(\text{coordinates})$)
  \STATE coordinates $\leftarrow$ $G(\text{coordinates})$
  \STATE INCREMENT count
  \STATE inFundamentalDomain $\leftarrow$ \FALSE
  \ENDIF
  \ENDFOR
  \IF {inFundamentalDomain}
  \STATE BREAK for
  \ENDIF
  \ENDFOR
  \FOR{ each BaseSphere $S$ in BaseSpheres}
  \STATE $d \leftarrow$ min($d$, scalingFactor $*$ (distance(coordinates, $S$.center) $-$
  $S$.radius) $/$ (absolute value of $dr$))
  \ENDFOR
  \RETURN $d$
 \end{algorithmic}
\end{algorithm}

We accumulate the Jacobian of inversions by multiplying the Jacobian for
every inversion.

%% ÂêåÊßò„Å´„Åó„Å¶sphere inverasion„Å´„Çà„Çã„Éï„É©„ÇØ„Çø„É´„ÇíÊèèÁîª„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÇãÔºéÂêå
%% „ÅòÈ†òÂüü„Å´„ÅÇ„Çã„Å®‰ªÆÂÆö„ÅóÔºå„Åô„Åπ„Å¶„ÅÆÂÜÜ„ÅÆÂ§ñÂÅ¥„Å´ËêΩ„Å°„Çã„Åæ„ÅßÂèçËª¢„ÇíÁπ∞„ÇäËøî„ÅôÔºé‰∏Ä
%% Âõû„ÅÆÂèçËª¢„Åî„Å®„Å´„É§„Ç≥„Éì„Ç¢„É≥„ÇíÁ¥ØÁ©ç„ÅóÔºåÊúÄÁµÇÁöÑ„Å´Á¥ØÁ©ç„Åó„Åü„É§„Ç≥„Éì„Ç¢„É≥„ÅßË∑ùÈõ¢„ÇíÂâ≤„ÇãÔºé
%% $Jacobian = R^2 / distance(P,~S)^2$
%% ÊúÄÂæå„Å´ÔºåÁÇπ„ÅåÂ§ñÂÅ¥„Å´Âá∫„Å¶„Åó„Åæ„Å£„ÅüÂ†¥ÂêàÔºå„É¨„Ç§„Åå„Éï„É©„ÇØ„Çø„É´„ÇíÁ™Å„ÅçÊäú„Åë„Å¶„Åó„Åæ
%% „ÅÜÔºé„Åù„ÅÆ„Åü„ÇÅÔºåÂæó„Çâ„Çå„ÅüË∑ùÈõ¢„ÅØ„Çπ„Ç±„Éº„É™„É≥„Ç∞„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„ÇãÔºé

We have one more thing to consider because the above calculation is
a rough estimate.
%% ‰∏é„Åà„Çâ„Çå„ÅüÁÇπ„Åå„Éï„É©„ÇØ„Çø„É´„ÅÆÂ§ñÂÅ¥„Å´Âá∫„Å¶„Åó„Åæ„ÅÜ„Å®„ÅçÔºådistance function„ÅØ‰∫à
%% Êúü„Åõ„Åö„Åó„Å¶„Åä„Åä„Åç„Åè„Å™„Çä„Åô„Åé„Å¶„Åó„Åæ„ÅÑÔºåÁµêÊûú„Å®„Åó„Å¶„Éï„É©„ÇØ„Çø„É´„Å´„Ç¢„Éº„ÉÜ„Ç£„Éï„Ç°
%% „ÇØ„Éà„Åå„Åß„Åç„Å¶„Åó„Åæ„ÅÜ

\subsection{Related Works}

Aaron Montag uses texture based approach to visualize limit set of the
Kleinian groups \cite{Montag2014hyperbolicIFS}.
%% „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éô„Éº„Çπ„ÅÆÊèèÁîªÊñπÊ≥ï „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å´Á®Æ„Å®„Å™„ÇãÂÜÜ„ÇíÊèè„ÅçÔºåÂÜÜ„Å´Â§âÊèõ„Çí‰Ωú
%% Áî®„Åï„Åõ„Çã„Åì„Å®„ÅßÊ•µÈôêÈõÜÂêà„ÇíÊèèÁîª„Åï„Åõ„Çã

Jos Leys invented efficient algorithm to draw Kleinian group with Maskit
parametrization. IIS uses circle inversions on the other hand Jos Leys
uses normal generators.
%% IIS„ÇíÊôÆÈÄö„ÅÆÈñ¢Êï∞„Çí‰Ωø„Å£„Å¶Ë°å„Å£„Å¶„ÅÑ„Çã „Åì„Å°„Çâ„ÅÆIIS„ÅØÂÜÜÔºåÁêÉ„Å´Ê≥®ÁõÆ„Åó„Å¶„ÅÑ„Çã

Martin von Gagern introduce similar algorithm called \textit{Reverse
Pixel Lookup} \cite{journals/combinatorics/GagernR09}. The algorithm is for visualizing tiling.