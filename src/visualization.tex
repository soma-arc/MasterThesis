%#BIBTEX biber --bblencoding=utf8 -u -U --output_safechars main
%#!uplatex main.tex

\section{Visualization of Kleinian Groups}

\subsection{Basic Methods for Visualization}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/cayleyGraphabcd.png}
  \caption{\textit{Cayley Graph}}
  \label{fig:cayleyGraph}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/basic/circleOrbit.png}
  \caption{\textit{Orbit of the disks}}
  \label{fig:circOrbit}
  \hspace*{\fill}
 \end{minipage}
\end{figure}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.3333\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/basic/catCircleOrbit.png}
  \caption{\textit{The orbit of the cat}}
  \label{fig:orbitCat}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.3333\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/basic/hyperbolicTessellation.png}
  \caption{\textit{Hyperbolic Tessellation}}
  \label{fig:hypTiling}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.3333\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/limitSet/limit.png}
  \caption{\textit{Limit set of the Kleinian group}}
  \label{fig:limit}
  \hspace*{\fill}
 \end{minipage}
\end{figure}

\noindent In this sub-section, we introduce basic methods for
visualizing extended Kleinian groups.
For simple example, we explain an extended Kleinian group generated by
%ここでは，各行の後にコメントします．
% We explain an simple example of extended Kleinian groups generated by
four inversion mappings.

First of all, to visualize a group we consider \textit{Cayley graph}.
%  a \textit{Cayley graph}.
Cayley graph is for a group $G$ given a generators
% A Cayley graph is defined as follows.  Let $G$ be a group and we fix a set of generators.
all elements of $G$ are nodes and multiplication of generators by
% A node of a Cayley graph is an element of $G$, and an edge of a Cayley graph connects
right to be related two elements connected by edges.
% two nodes which are related by right-multiplication of a generator. 
For an easy example, we assume a group generated by four
involutions, which is a map whose square coincises to the identity.
% coincises -> coincides
In short, it is a following group.
% a -> the
\[ G=\langle a,b,c,d \mid a^2=b^2=c^2=d^2 = \mathrm{id} \rangle \]

The Cayley graph of the group is shown in Figure\ref{fig:cayleyGraph}.
% the group $G$ 
The element of the group is nodes. Four edges corresponds to 
% nodes -> a node
% corresponds -> correspond
$a, b, c, d$ are emitted from each node.
Because $a, b, c, d$ are involution, $a=a^{-1}$ and
an edge corresponds to inverse mapping is not needed.
% inverse mapping -> an inverse map
In Figure \ref{fig:cayleyGraph}, we put identity element $\mathrm{id}$
% identity -> the identity
to center and four edges are stretching symmetrically.
% center に冠詞が付かないのが気になる．
In Cayley graph, length of an edge from identity give the shortest
% a Cayley
% the graph distance from the identity to a node gives 
length of a word.
% a word representing the node.

We can find that the length of the words multiplied by three
% We can find that the number of words of the same length grows multiplied by three, 
that is to say words with length one is four, words with length two are
% words -> the number of words (4か所)
twelve, words with length three are thirty six, and words with length
$n$ are $4 \cdot 3^{n-1}$

The visualized image is Figure \ref{fig:circOrbit}. In this image,
we draw four circles on the plane, and we call their inversion mapping
% mapping はカット．以下も同様．
% 写像という意味ではmapを使い，inversionなどのそもそも写像を表す単語にはmappingをつけずにinversionだけで通じる．
% 正直，inversion mappingというと数学のシロウト臭がするので個人的意見として避けてほしいです．
$a, b, c,$ and $ d$ respectively. Four circles come in touch, but do not cross,
and there are no relational expression between $a$, $b$, $c$, and $d$.
% and -> and hence（はどうでしょう・・・）
Thus, extended M\"obius transformation group generated by four inversion
% the extended ...
% four inversion -> these four inversion
mapping is isomorphic group to $G$ above.
% is isomorphic group to $G$ above -> is group isomorphic to above $G$
In Figure \ref{fig:orbitCat}, the cat drew in center are moved by
% drew -> drawn では
% in center -> in the center
% are -> is
inversion mapping, and visualized ``orbit space of the cat''.
% inversion mapping -> inversions
% visualized ''orbit ***'' -> ''the orbit **'' is visualized.
We can find that the orbit space of the cat corresponds to nodes of
the graph.

In order to draw orbit space of the cat, there are breadth first search
% orbit -> the orbit
algorithm.
In the following, we explain breadth first search algorithm.
First of all, we draw the cat in center, and
next, we draw transformed cat by the words whose length is one,
% cat -> cats
and we draw transformed cat by the word whose length is two.
% cat -> cats
We continue iterating these processes.
This is breadth first search algorithm.
The tessellation shown in Figure \ref{fig:hypTiling} is also drawn by
Breadth First Search Algorithm.
% なぜここだけ大文字？

Visualization of this algorithm are easy to implement and understand．
% of -> by?
% are -> is
% easy -> easy for us (のほうがわかりやすいです)
We can roughly understand its actions of the groups.
% 前の文章とのつながりが悪いです．何をするとラフに理解できるのかが，この文章だと明確ではないです．
However, there are defective what the computational complexity is  
% there are defective what -> this method has a fault because くらいでどうでしょうか．
easy to increase and it takes too much times.

Also, there is one more method of traversing graph.
% one more よりも another のほうが「別のもう一つ」という語感になります
It is called depth first search.
This one can draw only limit set directly.
% 主語が間違っています．Using this algorith, we can draw only thelimit set directly.です．
See Figure \ref{fig:limit}. This shows an only limit set of a Kleinian
% an only limit set -> only the limit set
group.
However, we do not use this algorithm in this paper.
For more details of the algorithm, read \cite{MumfordSeriesWright200204}.
% the algorithm は上二つを指すと思われるのでthe above methods　くらいでしょうか．

\subsection{Iterated Inversion System (IIS)}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level0c.pdf}
  \subcaption{}
  \label{fig:level0}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level0invc.pdf}
  \subcaption{}
   \label{fig:level0inv}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level1c.pdf}
  \subcaption{}
   \label{fig:level1}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in,
  keepaspectratio]{./img/preparation/orbit/level1invc.pdf}
  \subcaption{}
  \label{fig:level1inv}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{./img/preparation/orbit/level2c.pdf}
  \subcaption{}
  \label{fig:level2}
 \end{minipage}
 \begin{minipage}[t]{0.16\hsize}
  \center
  \includegraphics[width=1in, height=1in, keepaspectratio]{img/preparation/orbit/levelMaxc.pdf}
  \subcaption{}
  \label{fig:levelMax}
 \end{minipage}
 \caption{\textit{The process of rendering the orbit of disks}}
 \label{fig:schottkyProcess}
\end{figure}

\noindent To solve the problems we discussed in the previous sub-section,
we focus circle inversions and invent an efficient algorithm to
visualize circle inversion fractals shown in Figure \ref{fig:schottkyProcess}\subref{fig:levelMax}.
% circle -> the circle
The algorithm is called \textit{Iterated Inversion System (IIS.)}
It can visualize not only two-dimensional circle inversion fractals but
also three-dimensional sphere inversion fractals.

The fractal in Figure \ref{fig:schottkyProcess}\subref{fig:levelMax} shows the orbit of the first
four circles in Figure \ref{fig:schottkyProcess}\subref{fig:level0}. 
%% TODO もうすこし説明を加える <- そうしてください．
It is also a Kleinian group composed of four circle inversions.
Especially, it is called a \textit{quasi-fuchsian group}.
% limit setが正円になる時にはfuchsian groupと言います．この例はlimit setは正円ですので，これはfuchsian groupです．
% limit setが閉曲線で正円ではないとき， quasi-fuchsian groupと呼びます．ですので，円が輪状につながり，フラクタル上の閉曲線が
% できるときはquasi-fuchsian groupと呼ばれます．
% 閉曲線より複雑な形をしている時にはクライン群以外に特に名前はありません．
The process of generation of circle inversion fractals is
as follows.

\begin{enumerate}
 \item We need some disjoint disks to obtain circle inversion fractals.
       For example, we assume there are four orange disks as shown in
       Figure \ref{fig:schottkyProcess}\subref{fig:level0}. We call orange disks \textit{initial
       disks} and their boundary \textit{initial circles}.
 \item First of all, we focus on the white circle in Figure
       \ref{fig:schottkyProcess}\subref{fig:level0inv}. The inversion in the white circle moves the
       other three disks into the interior of the white circle.
 \item After we apply each inversion in the initial circle to the outer disks,
       we obtain twelve small disks. They are shown in Figure \ref{fig:schottkyProcess}\subref{fig:level1}.
 \item Next, we invert the twelve small disks in the initial circles.
       The inversion in the white circle moves the outer nine small disks
       into the interior of the white circle as shown in Figure \ref{fig:schottkyProcess}\subref{fig:level1inv}.
       Each inversion in the initial circle generates smaller disks, and we
       obtain Figure \ref{fig:schottkyProcess}\subref{fig:level2}.
 \item We continue iterating these processes, that is, we continue
       applying each inversion in the initial circle to resulting
       smaller disks.
       Finally, we get Figure \ref{fig:schottkyProcess}\subref{fig:levelMax}.
\end{enumerate}

\subsubsection{Two Dimensional IIS}

\begin{figure}[htbp]
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/orbIIS.png}
  \caption{\textit{Orbit of blue point by IIS}}
  \label{fig:iisOrbit}
 \hspace*{\fill}
\end{figure}

 \begin{algorithm}
  \caption{Iterated Inversion System (IIS)}
  \label{arg:iis2d}
  \begin{algorithmic}
   \REQUIRE count $= 0$ and coordinates $=$ position determined by
   pixel
   \FOR{$i=0$ to MAX\_INVERSION}
   \STATE inOutside $\leftarrow$ \TRUE
   \FOR{ each Map $G$ in circles }
   \IF{$G$ is available to coordinates}
   \STATE coordinates $\leftarrow$ $G(\text{coordinates})$
   \STATE INCREMENT count
   \STATE inOutside $\leftarrow$ \FALSE
   \ENDIF
   \ENDFOR
   \IF {inOutside}
   \STATE BREAK for
   \ENDIF
   \ENDFOR
   \STATE RETURN count
  \end{algorithmic}
 \end{algorithm}

\noindent IIS computes the depth of the circles point by point.
Thus, we can perform parallel processing and render the images efficiently.
The images in this paper are rendered using \textit{OpenGL Shading
Language (GLSL)}.
% どの範囲の画像が該当するのか（第＊章の画像は，のように）を明確にするとよい．論文にわたって全てであればAll ofを最初につける．

IIS is applied to each point on the plane and computes nesting depth of
% is -> can be のような気がする
the disk which contains the point.
The process of the algorithm is as follows.
First of all, if the point is contained in initial disks, we invert the
point in the boundary circle of the disk.
We continue applying inversions until the transformed point is in the
outside of the initial disks.
Figure \ref{fig:iisOrbit} shows the orbit of the blue point transformed by
iterations of inversions.

Furthermore, a point actually at the limit set never reaches the
outside. So, we have to determine the maximum number of iterations in
advance to prevent the algorithm from running indefinitely.
The points except for the limit set are guaranteed that they
are transformed to outside because inversions are involution.

Pseudo-code of IIS is shown in Algorithm \ref{arg:iis2d}.
Later, we will introduce generators other than simple inversions.
% Later in section 2.3.3, のように具体的に
Thus, we consider a map $G$ such that $G$ is an identity for a point in the
% a map $\gamma : \mathbb{C} \to G$ such that $\gamma(p)$ is the unit for a point $p$ in the
\textit{fundamental domain} and that $G$ is a composition of inversions for other
% $G$ -> $\gamma(p)$ 写像を考えると言っているので，集合から集合への対応を提示しないといけない．
points.
The fundamental domain is the terminal area of transformations. 
In the above case, the black area where outside of all circles. 
% black area consists of the outside and the boundary of all circles is the fundamental domain.

\subsubsection{Three Dimensional Extension}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/3dExtension/3dKissingGenerator.png}
  \subcaption{\textit{Generator}}
  \label{fig:simpleGen}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/3dExtension/3dOrbit.png}
  \subcaption{\textit{The orbit of spheres}}
  \label{fig:simpleOrb}
  \hspace*{\fill}
 \end{minipage}
 \caption{\textit{The orbit of the sphere inversion fractal}}
 \label{fig:simpleGenOrb}
\end{figure}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/sphereTracing1.png}
  \subcaption{\textit{}}
  \label{fig:st1}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/sphereTracing2.png}
  \subcaption{\textit{}}
  \label{fig:st2}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/sphereTracing3.png}
  \subcaption{\textit{}}
  \label{fig:st3}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/sphereTracing4.png}
  \subcaption{\textit{}}
  \label{fig:st4}
  \hspace*{\fill}
 \end{minipage}
 \caption{\textit{Sphere tracing}}
 \label{fig:sphereTracing}
\end{figure}

In a similar manner to the two-dimensional algorithm,
we extend the IIS to visualize three-dimensional Kleinian groups.
% クライン群としての次元は一つ上なので，three-dimensional Keleinian fractalsくらいにしておきますか．
We extend circle inversion to sphere inversion easily, and we
% We extend the IIS algrithm by replacing circle inversions to sphere inversions easily, ..
compute the nesting depth of the sphere voxel by voxel.

We use \textit{ray tracing} to visualize three-dimensional objects.
Ray tracing computes an intersection between a ray and objects
algebraically.
% この後ににある3つの文は，何が話題なのかわかりにくいです．
% 「circle inersion fractal のようなものを3次元空間内の球でそのまま考えると」という説明がほしいです．
% 球体の中に無限個の球体が含まれるような絵（これがnesting spheresの中身ですね）になる，
There are two ways to render nesting spheres. First one is to draw
% 上の説明があれば，nesting spheres -> the nesting spheres になります．
nesting spheres as transparent spheres.
Second one is \textit{volume rendering}.
However, these are difficult to render them efficiently, and
% it is difficult to render these two way of imaging efficiently, 
visualized images are not interesting.
% interestingは主観的な語ですので，客観的な形容詞に変更してください．

Therefore we render the orbit of the sphere in a similar way to the
two-dimensional circle inversion fractals.
% 文末に by using IIS をつけてはどうでしょうか．
See Figure \ref{fig:simpleGenOrb}\subref{fig:simpleGen}. It shows
white six inversion spheres and a green seed sphere.
Figure \ref{fig:simpleGenOrb}\subref{fig:simpleOrb} shows the orbit of
the green sphere transformed by inversions in white spheres.

We use \textit{sphere tracing} \cite{hart1996sphere} to render three-dimensional
fractals and orbit of the seed sphere.
Sphere Tracing is one of the algorithms to render implicit surfaces using
ray tracing.
In the following paragraphs, we introduce ray tracing and
sphere tracing.

In the first place, we work a ray as something like a vector.
We set the origin of the ray to the position of the camera
and direction of the ray to the direction to each pixel on the screen
from the camera. Each pixel is colored according to the
first object the ray hits. 

In regular ray tracing, we calculate the intersections algebraically, but
% ray tracing に冠詞が付かないのはいいかなと思うのですが，regularという形容詞が付いた場合は，ちょっと迷います．
% いつものアレ的な感じならば定冠詞がいいでしょう．
% intersections between the ray and the object albraically,
we can not compute intersection to fractal objects.
% intersection は2者の関係のうえに成立する概念ですから，「何と何の交わり」をはっきりさせるか「その交わり」と前を受けるかどちらかです．
% it is impracticable to compute the intersections to ... 
On the other hand, in sphere tracing, we march the ``tip'' of the ray
% 気持ち的な問題ですが，普通のレイトレでは厳しいので「その代わりの方法として」的なニュアンスが出るといいかなと思います．
% As an alternating methods, ではどうでしょうか．
% march は自動詞なので，we make the tip of the ray marching along くらいしかなと思います．
along the direction of the ray step by step. 
To check how far the tip of the ray is from the objects, we need a
\textit{distance function}.
The distance function is a function which returns the minimum distance
between given point and objects.
% given point -> a given point
% objects -> the object
For example, a distance function of a sphere is as follows.
% as follows で悪くありませんが，別法で can be obtained easily.などでもよさそうです．
Let $P$ be a tip of a ray, let $C$ and $R$ be center and
radius of the sphere.
% the center and the radius of the sphere respectively
A distance function of sphere $f(P)$ is $f(P) = distance(P, C) - R$.
% is -> is given by 
If there are many spheres, we use minimum distance to objects.
% we use the minimum of the distance functions of the spheres.

Figure \ref{fig:sphereTracing} shows sphere tracing algorithm.
The yellow arrow is ray and orange disks are visible objects.
% ray -> a ray
% visible -> the visible
First of all, in Figure \ref{fig:sphereTracing}\subref{fig:st1},
we use distance function and find minimum distance between
% distance -> a distance (theか？)
% minimum -> the minimum
the ray and the disk.
% ray -> tip of the ray
% disk -> disks
Next, we put the ray forward and apply distance function to the position
% ray -> tip 
of the ray as in Figure \ref{fig:sphereTracing}\subref{fig:st2}.
Again, we apply distance function and march the ray, and we obtain
% distance -> a distance (theか？)
% march the ray -> march the tip もしくは make the tip marching 
% 他動詞としてのmarch は「＊＊＊を進軍させる」という雰囲気で，この場面のイメージに合うかどうか・・・
Figure \ref{fig:sphereTracing}\subref{fig:st3}.
We continue iterating this processes until the value of the distance
function is less than zero as shown in Figure \ref{fig:sphereTracing}\subref{fig:st4}.
% 「０未満」と言っていますが，「小さな正の閾値未満ならば」でなくて大丈夫ですか．
% 「object のあいだをすり抜けた場合」には「distance function が十分に大きくなったらやめる」ということも必要です．

However, in regard to fractal rendering, it is difficult to
get an actual distance to its shape. So, we use a lower estimated distance
% to its shape -> from a given point to the object.
as a return value of the distance function. The technique to approximate
distance is called \textit{distance estimation}.
% a distance (具体的な距離の場合は可算名詞)
For more details about fractal rendering and distance estimation, see also the blog
post\footnote{Mikael H Christensen, Distance Estimated 3D Fractals (Part I):\\ \quad\quad
\url{http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/}}
by Christensen. 

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/translate1.png}
  \subcaption{\textit{}}
  \label{fig:modulo1}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/translate2.png}
  \subcaption{\textit{}}
  \label{fig:modulo2}
  \hspace*{\fill}
 \end{minipage}
 \caption{\textit{Fold space by modulo operator}}
 \label{fig:moduloAll}
\end{figure}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/scaling1.png}
  \subcaption{\textit{}}
  \label{fig:iisScale1}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/visualization/scaling2.png}
  \subcaption{\textit{}}
  \label{fig:iisScale2}
  \hspace*{\fill}
 \end{minipage}
 \caption{\textit{Fold space by scaling}}
 \label{fig:iisScaleAll}
\end{figure}

Before we introduce distance estimation, we show
% 気持ちとしては，「distance estimation の詳細を紹介する前に」
well-known technique to render many objects in sphere tracing.
% 単にmany ではちょっと違うような気がする．many objects lined up in a rowではどうですか．
Instead of preparing distance functions for many objects, we can use modulo operator
to get the distance to the lined up objects.

See Figure \ref{fig:moduloAll}\subref{fig:modulo1}. We assume there are the blue disk, the
yellow ray, and dotted circle and lines.
Now, we want to draw all of the dotted circles.
So, we want a minimum distance between the ray and dotted circles.
% the niminum 
% ray -> tip of the ray (?)
However, we only know the position of the tip of the ray and the blue disk.
% If we only know .... disk, then how can we get the minimum distance?
Thus, we assume the nearest circle to the ray is in the same dotted region, and
we fold up the regions using the modulo operator.
We can measure the distance to blue disk as in Figure \ref{fig:moduloAll}\subref{fig:modulo2}.
Finally, we can obtain minimum distance to line upped disks.
% the minimum

Next, we consider scaling example.
See Figure \ref{fig:iisScaleAll}\subref{fig:iisScale1}.
There are a yellow ray and a blue disk, and orbit of scaling as
dotted blue circles.
The green dotted lines show scaling regions.
We want to minimum distance between dotted blue circles and the ray.
% to -> to get the
% the blue circles and the tip of the ray
However, we only know the coordinates of the original blue
% If we only know .... , then how can we get the minimum distance?
disk and tip of the ray.
We assume that the nearest sphere to the tip of the ray is in
same regions. 
Thus, we scale the tip of the ray to the same region to the blue disk
but, the distance between scaled ray and disk is also scaled.
So, we correct the scale dividing computed distance by 
% correct the scale dividing computed distance by Jacobian
% -> correct the distance by the ratio determined by Jacobian (correctはmodifyでもいいかもです．)
Jacobian (sometimes referred to as the Jacobian determinant) of scaling.
% scaling -> scaling transformation (scaleという言葉が繰り返されているので．)
See Figure \ref{fig:iisScaleAll}\subref{fig:iisScale2}.
If the scaling of the circle is $f(z) = 2z$, we divide the distance by
$2^{-3}$ because the ray is moved three green scaling regions.
% the ray is moved to the 3 regions away from the original.

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/slice.png}
  \caption{\textit{XY-slice image of Figure \ref{fig:simpleGenOrb}\subref{fig:simpleOrb}}}
  \label{fig:slice2d}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/artifact.pdf}
  \caption{\textit{artifact}}
  \label{fig:3dartifact}
  \hspace*{\fill}
 \end{minipage}
\end{figure}

\begin{algorithm}
 \caption{Distance Function}
 \label{iis3d}
 \begin{algorithmic}
  \REQUIRE count $= 0$, $d$ = MAX\_DISTANCE, $dr = 1.0$, and coordinates
  $=$ tip of the ray
  \FOR{$i=0$ to MAX\_INVERSION}
  \STATE inFundamentalDomain $\leftarrow$ \TRUE
  \FOR{ each Map $G$ in Maps}
  \IF{$G$ is available to coordinates}
  \STATE $dr \leftarrow dr * $ (Jacobian of $G(\text{coordinates})$)
  \STATE coordinates $\leftarrow$ $G(\text{coordinates})$
  \STATE INCREMENT count
  \STATE inFundamentalDomain $\leftarrow$ \FALSE
  \ENDIF
  \ENDFOR
  \IF {inFundamentalDomain}
  \STATE BREAK for
  \ENDIF
  \ENDFOR
  \FOR{ each BaseSphere $S$ in BaseSpheres}
  \STATE $d \leftarrow$ min($d$, scalingFactor $*$ (distance(coordinates, $S$.center) $-$
  $S$.radius) $/$ (absolute value of $dr$))
  \ENDFOR
  \RETURN $d$
 \end{algorithmic}
\end{algorithm}

In a similar manner to scaling, we can render sphere inversion
fractals.
For the sake of simplicity, we consider a slice image of Figure
\ref{fig:simpleGenOrb}.
See Figure \ref{fig:slice2d}. This image shows the XY-slice of the orbit
of spheres.
Orange disks in the background are slices of the orbit of initial inversion spheres.
% the initial
Slices of the orbit of the base sphere are colored in
the same color as the orbit shown in Figure \ref{fig:simpleGenOrb}\subref{fig:simpleOrb}.
In Figure \ref{fig:slice2d},
$C$ is the white circle, the boundary of the initial inversion sphere.
$S1$ is the base sphere and the inversion of $S2$ in the circle $C$. 
The white point $P1$ is the inversion of $P2$ in the circle $C$.

Now we assume that the tip of the ray is at $P2$.
Let's calculate the minimum distance between
$P2$ and the orbit of base spheres.
The nearest sphere to $P2$ is $S2$.
So, we have to calculate the distance between $P2$ and $S2$.
We call the distance $d$.
However, we do not know the center and radius of $S2$.
So, we calculate $d$ from a distance between $S1$ and $P1$.
Inversions in spheres and M\"obius transformations do not preserve
Euclidean distance.
Thus we use the Jacobian to estimate the distance.
We accumulate the Jacobian of inversions by multiplying the Jacobian for
every inversion.

Finally, we divide the distance between the base sphere and the point on
the fundamental domain by the accumulated Jacobian, and we can get the
approximated distance between the tip of the ray and the nearest sphere.
For the above case, we get an inequality $d \geq distance(P1, S1)/Jacobian$.
The formula gives a lower bound for spheres.
For more details on the derivation of this estimation formula, see the
blog post\footnote{Inigo Quilez, distance estimation:
\url{http://www.iquilezles.org/www/articles/distance/distance.htm}}
by Inigo Quilez.

We have one more thing to consider because the above calculation is
a rough estimate.
For example, if a given point is in the outer area of the orbit, the
distance function returns unintentionally large distance, and the ray
can pass through the real objects. This causes artifact shown in Figure
\ref{fig:3dartifact}. The fore part of the fractals is not rendered.
In order to avoid this kind of problems, we shrink the length of
% problem -> trouble (?)
the estimated distance.
It increases the number of steps of sphere tracing, but we can
%この主語のItは何を指しているかがわかりません．It increases that ... かな．
eventually obtain the intersection of the ray and the spheres.
The scaling factor is determined experimentally according to the size of
the spheres.

The generalized pseudo-code for a distance function is in Algorithm \ref{iis3d}. 

\subsection{Related Works}

\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/related/josklein.png}
  \caption{\textit{The limit set of the Kleinian groups with Maskit parametrization.}}
  \label{fig:jos}
  \hspace*{\fill}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \center
  \includegraphics[height=1.35in, keepaspectratio]{img/preparation/related/joskleinInv.png}
  \caption{\textit{The limit set applied inversions of the circles.}}
  \label{fig:josInv}
  \hspace*{\fill}
 \end{minipage}
\end{figure}

Aaron Montag uses texture based approach to visualize a limit set of the
Kleinian groups \cite{Montag2014hyperbolicIFS}.
We prepare initial seed circle in the texture.
Next, we apply generators of the group to each pixel.
If the transformed pixel is on the seed circle or filled pixel, we fill the original pixel.
We continue iterating this process; we obtain an image of the limit set of
the group.
This algorithm needs high-resolution texture, and it is difficult to
extend this algorithm to three-dimension.

Jos Leys invented efficient algorithm to draw a Kleinian group with Maskit
parametrization shown in Figure
\ref{fig:jos}\footnote{\url{http://www.josleys.com/article_show.php?id=221}}. 
The pink points are control points of the fractal.
IIS uses circle or sphere inversions, on the other hand, Jos Leys used
M\"obius transformations algebraically.
% この文章，意味は分かるのですが，なんか言葉足らずな気がします．
%IISは反転を利用したアルゴリズムですが，(Although出始めてはどうか？）Leysのアルゴリズムは・・・・
He observes the orbit of the Maskit parametrization group and
successfully discover the algorithm to visualize Maskit groups.
We can apply circle inversions to his figure, and we obtain Figure \ref{fig:josInv}.

Martin von Gagern and J\"urgen Richter-Gebert introduced an algorithm
called \textit{Reverse Pixel Lookup}
\cite{journals/combinatorics/GagernR09} to render two-dimensional
hyperbolic tiling.
The algorithm is similar to ours, but
we explore the method not only tiling but also other varieties of
images, for instance, three-dimensional objects.

% 最後のほうは，特に問題が見当たりませんでした！
